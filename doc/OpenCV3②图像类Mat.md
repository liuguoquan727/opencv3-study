OpenCV3②图像类Mat
===

[TOC]

# Mat 类

Mat 类是从 OpenCV 2.0 开始用来表示图片数据结构的 C++ 类，主要解决了1.0中内存管理的问题，使用 Mat 类后，我们不必再手动开辟空间，不必再在不需要时立即将空间释放，Mat 类引入的自动内存管理功能。

Mat 类由两个数据部分组成：矩阵头（包含矩阵大小、存储方法、存储地址等信息）和一个指向存储所有像素值的矩阵；矩阵头的大小是常量值，矩阵的大小依据图像的不同而不同，通常比矩阵头的大小大数个数量级。因此当在程序中传递图像并创建副本时，大量的开销是由矩阵造成的，而不是矩阵头。为了解决这个问题，**OpenCV使用了引用计数机制，其思路是让每个 Mat 对象有自己的信息头，但共享同一个矩阵，这通过让矩阵指针指向同一个地址而实现，而拷贝构造函数则只复制信息头和矩阵指针，而不复制矩阵。**

```cpp
Mat A, C; //仅创建信息头部分
A = imread("../lena.jpg",1)； //为矩阵开辟内存
Mat B(A); //使用拷贝构造函数
C = A; //复制运算符
```
>以上所有的 Mat 对象最终都指向同一个也是唯一一个数据矩阵，虽然他们的信息头不同，但通过任何一个对象所做的改变也会影响其他对象。

我们还可以创建只引用部分数据的信息头，比如下面创建一个感兴趣区域（ROI），只需创建包含边界信息的信息头：

```cpp
Mat D(A, Rect(10,10,100,100)); //使用矩形界定
Mat E = A(Range:all(),Range(1,3)); //使用行和列来界定
```

如果想复制矩阵本身（不只是信息头和矩阵指针），这时可以使用函数`clone()`或者`copyTo()`

```cpp
Mat F = A.clone();
Mat G;
A.copyTo(G);
```
>现在改变 F 或者 G 就不会影响 Mat 信息头所指向的矩阵。

**如果矩阵属于多个 Mat 对象，那么当不再需要它时，谁来负责清理呢？**答案是：最后一个使用它的对象，我们无论什么时候复制一个 Mat 对象的信息头，都会增加矩阵的引用次数，相反当一个头被释放之后，这个计数被减一；当计数值为零时，矩阵会被清理。

# 创建 Mat 对象

## imread()

```
Mat image = imread("../lena.png");
```

## 无参构造函数

```cpp
image = Mat();
image.create(4,4,CV_8UC3);
cout << "M = " << image << endl;
```
>表示创建一个 4 * 4 大小的像素块，每个像素都是三通道，每个通道都是8位。CV_8UC3 中的8表示8位，UC 表示 uchar 类型，3 表示三个通道。

## 构造函数

```cpp
image = Mat(4,4,CV_8UC3);
cout << "M = " << image << endl;
```

## Size和Scalar

```cpp
image = Mat(4,4,CV_8UC3,Scalar(0,255,255));
cout << "M = " << image << endl;

image = Mat(Size(4,4),CV_8UC3,Scalar(255,255,255));
cout << "M = " << image << endl;
```
*   `Size(4,4)`表示4 * 4 像素矩阵。
*   `Scalar(0,255,255)`：指定的三通道颜色值

## eye

```cpp
image = Mat::eye(4,4,CV_8UC3);
cout << "M = " << image << endl;

M = [  1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0]
```

## ones

```cpp
image = Mat::ones(4,4,CV_8UC1);
cout << "M = " << image << endl;

M = [  1,   1,   1,   1;
   1,   1,   1,   1;
   1,   1,   1,   1;
   1,   1,   1,   1]
```
>1通道颜色值颜色值都为1

## zeros

```cpp
image = Mat::zeros(4,4,CV_8UC3);
cout << "M = " << image << endl;

M = [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]
```

>三通道颜色值颜色值都为0

# 复制 Mat 对象

## 只复制信息头

```cpp
Mat m = Mat(4,4,CV_8UC3);
Mat m2;
m2 = m;

Mat m3;
m3(m);
```

## 矩阵完全复制

```cpp
Mat m4;
m4 = m.clone();

Mat m5;
m.copyTo(m5);
```

